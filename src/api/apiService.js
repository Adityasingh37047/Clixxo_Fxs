import axiosInstance from "./axiosInstance";
import axios from "axios";

// GROUP API Functions
export const listTrunkIds = async () => {
  try {
    const response = await axiosInstance.post("/group", {
      type: "list_trunk_id"
    });
    return response.data;
  } catch (error) {
    console.error("Error fetching trunk IDs:", error.message);
    throw error;
  }
};

export const addGroup = async (data) => {
  try {
    const response = await axiosInstance.post("/group", {
      type: "add",
      data: data
    });
    return response.data;
  } catch (error) {
    console.error("Error adding group:", error.message);
    throw error;
  }
};

export const updateGroup = async (id, data) => {
  try {
    const response = await axiosInstance.post("/group", {
      type: "update",
      data: { id: String(id), ...data }
    });
    return response.data;
  } catch (error) {
    console.error("Error updating group:", error.message);
    throw error;
  }
};

export const listGroups = async () => {
  try {
    const response = await axiosInstance.post("/group", {
      type: "list"
    });
    return response.data;
  } catch (error) {
    console.error("Error fetching groups:", error.message);
    throw error;
  }
};

export const deleteGroup = async (id) => {
  try {
    const response = await axiosInstance.post("/group", {
      type: "delete",
      data: { id: String(id) }
    });
    return response.data;
  } catch (error) {
    console.error("Error deleting group:", error.message);
    throw error;
  }
};
export const  fetchSystemInfo = async () => {
  try {
    const response = await axiosInstance.get("/system-info"); 
    return response.data;
  } catch (error) {
    console.error("Error fetching system info:", error.message);
    throw error;
  }
};



// export const  fetchPingtest = async () => {
//   try {
//     const response = await axiosInstance.get("/ping-test"); 
//     return response.data;
//   } catch (error) {
//     console.log("Error fetching ping test:", error.message);
//     throw error;
//   }
// };

export const postPingtest = async (data) => {
  try {
    const response = await axiosInstance.post("/ping-test", data);
    return response.data;
  } catch (error) {
    console.error("Error posting ping test:", error.message);
    throw error;
  }
};


// export const fetchTracerttest = async ()=>{
//   try{
//     const response = await axiosInstance.get("/tracert-test");
//     return response.data;
//   } catch (error){
//     console.error(" Error fatching tracert test:", error.message);
//     throw error;
//   }
// };

export const postTracerttest = async (data) => {
  try {
    const response = await axiosInstance.post("/tracert-test", data);
    return response.data;
  } catch (error) {
    console.error("Error posting tracert test:", error.message);
    throw error;
  }
};

export const postAsteriskCLI = async (data) => {
  try {
    const response = await axiosInstance.post("/asterisk", data);
    return response.data;
  } catch (error) {
    console.error("Error executing Asterisk CLI command:", error.message);
    throw error;
  }
};

// Linux CLI - run Linux shell commands on the device
export const postLinuxCmd = async (data) => {
  try {
    const response = await axiosInstance.post('/linuxcmd', data);
    return response.data;
  } catch (error) {
    console.error('Error executing Linux command:', error.message);
    throw error;
  }
};


// Software Update Upload
export const uploadSoftwareUpdate = async (file) => {
  try {
    const formData = new FormData();
    formData.append('file', file);

    const response = await axiosInstance.post('/update_upload', formData, {
      headers: { 'Content-Type': 'multipart/form-data' },
      timeout: 120000,
    });

    return response.data;
  } catch (error) {
    console.error('Error uploading software update:', error.message);
    throw error.response?.data || error;
  }
};


export const fetchNetwork = async ()=>{
  try{
    const response = await axiosInstance.get("/get-network-settings");
    return response.data;
  }catch (error){
    console.log("Error fatching Network", error.message);
    throw error;
  }
};


export const resetNetworkSettings = async () => {
  try {
    const response = await axiosInstance.get("/reset-network-settings");
    return response.data;
  } catch (error) {
    console.log("Error resetting network settings", error.message);
    throw error;
  }
};


export const saveNetworkSettings = async (data)=>{
  try{
    const response = await axiosInstance.post("/save-network-settings", data, { timeout: 30000 });
    return response.data;
  }catch (error){
    console.log("Error saving network settings", error.message);
    throw error;
  }
};

  export const fetchLogin = async (data)=>{
  try{
    const response = await axiosInstance.post ("/login", data);
    return response.data;
  }catch (error){
    console.log("Login Failed.... Please check your username and password", error.message);
    throw error;
  }
};

export const fetchChangePassword = async (data) => {
  try {
    console.log('ðŸ” Changing password with data:', data);
    const response = await axiosInstance.post('/change-password', data);
    console.log('ðŸ” Change password response:', response.data);
    return response.data;
  } catch (error) {
    console.log('Error Changing Password', error.message);
    throw error;
  }
};

export const systemRestart = async ()=>{
  try{
    const response = await axiosInstance.get ("/system-restart");
    return response.data;
  }catch (error){
    console.log("Error restarting system", error.message);
    throw error;
  }
};


export const serviceRestart = async () => {
  try {
    const response = await axiosInstance.get("/service-restart");
    return response.data;
  } catch (error) {
    console.log("Error restarting service", error.message);
    throw error;
  }
};

export const servicePing = async ()=>{
  try{
  const response = await axiosInstance.get ("/service-ping");
    return response.data;
  }catch (error){
    console.log("Error pinging service", error.message);
    throw error;
  }
};

// Channel State (PSTN) - fetch DAHDI channel runtime states
export const listChannelState = async () => {
  try {
    // This endpoint returns the runtime state of each DAHDI channel
    const response = await axiosInstance.post('/channelstate', { type: 'list' });
    return response.data;
  } catch (error) {
    console.error('Error fetching channel state:', error.message);
    throw error;
  }
};

export const fetchManagementParameters = async () => {
  try {
    const response = await axiosInstance.get('/get-management-parameters');
    console.log('ðŸ” Fetch management parameters response:', response.data);
    return response.data;
  } catch (error) {
    console.log("Error fetching management parameters", error.message);
    throw error;
  } 
};

export const saveManagementParameters = async (data) => {
  try {
    console.log('ðŸ’¾ Saving management parameters:', data);
    const response = await axiosInstance.post('/save-management-parameters', data);
    console.log('ðŸ’¾ Save management parameters response:', response.data);
    return response.data;
  } catch (error) {
    console.log("Error saving management parameters", error.message);
    throw error;
  }
};

export const resetManagementParameters = async ()=>{
  try {
    const response = await axiosInstance.get('/reset-management-parameters')
    return response.data;
  } catch(error){
    console.log('Error resetting management parameters', error.message);
    throw error;
  }
};

export const fetchAccountManageRegister= async (data)=>{
  try{
    const response = await axiosInstance.post('/register-user', data);
    return response.data;
  }catch(error){
    console.log('Error registering user', error.message);
    throw error;
  }
};

export const fetchAccountManageDelete= async (data)=>{
  try{
    const response = await axiosInstance.post('/delete-user', data);
    return response.data;
  }catch(error){
    console.log('Error deleting user', error.message);
    throw error;
  }
};  

export const fetchAccountManageGetAll= async ()=>{
  try {
    const response = await axiosInstance.get('/get-all-user');
    return response.data;
  }catch(error){
    console.log('Error getting all user', error.message);
    throw error;
  }
};


export const fetchAccountManageUpdate= async (data)=>{
  try{
      const response = await axiosInstance.post('/delete-user', data);
    return response.data;
  }catch(error){          
    console.log('Error updating user', error.message);
    throw error;
  }
};


export const fetchDhcpSettings = async()=>{
  try{
    const response = await axiosInstance.get('/fetch-dhcp-settings');
    return response.data;

  }catch(error){
    console.log('Error fetching dhcp settings', error.message);
    throw error;
  }
};

// Dhcp Server Settings
export const fetchSaveDhcpSettings = async(data)=>{
  try{
    const response = await axiosInstance.post('/save-dhcp-settings', data);
    return response.data;
  }catch(error){
    console.log('Error saving dhcp settings', error.message);
    throw error;
  }
};


export const fetchResetDhcpSettings = async()=>{
  try{
    const response = await axiosInstance.get('/reset-dhcp-settings');
    return response.data;
  }catch(error){
    console.log('Error resetting dhcp settings', error.message);
    throw error;
  }
};




// apiService.js


export const getLicenseInfo = async () => {
  try {
    const { data } = await axiosInstance.post('/license', { type: 'info' });
    return data;
  } catch (error) {
    console.error('Error fetching license info:', error);
    throw error.response?.data || { message: 'Server unavailable' };
  }
};

export const checkLicenseValidity = async () => {
  try {
    const { data } = await axiosInstance.post('/license', { type: 'check' }, {
      timeout: 20000 // 20 seconds timeout
    });
    return data;
  } catch (error) {
    console.error('Error checking license validity:', error);
    throw error.response?.data || { message: 'Server unavailable' };
  }
};

export const getSystemFingerprint = async () => {
  try {
    const { data } = await axiosInstance.post('/license', { type: 'system' });
    return data;
  } catch (error) {
    console.error('Error fetching system fingerprint:', error);
    throw error.response?.data || { message: 'Server unavailable' };
  }
};

export const uploadLicenseFile = async (file) => {
  try {
    const formData = new FormData();
    formData.append('file', file);

    const { data } = await axiosInstance.post('/licenseupload', formData, {
      headers: { 'Content-Type': 'multipart/form-data' },
    });

    return data;
  } catch (error) {
    console.error('Error uploading license file:', error);
    throw error.response?.data || { message: 'Server unavailable' };
  }
};





// SIP Account API Services
export const fetchSipAccounts = async () => {
  try {
    const response = await axiosInstance.post('/pjsip', {
      type: 'list'
    });
    return response.data;
  } catch (error) {
    console.error('Error fetching SIP accounts:', error);
    if (error.code === 'ECONNABORTED' || error.message === 'Network Error') {
      throw new Error('Network Error');
    }
    throw error.response?.data || { message: 'Server unavailable' };
  }
};

// SIP To SIP Account (IP Trunk) API Services - uses 'contact'
export const fetchSipIpTrunkAccounts = async () => {
  try {
    const response = await axiosInstance.post('/pjsip_ip_trunk', { type: 'list' });
    return response.data;
  } catch (error) {
    console.error('Error fetching SIP IP Trunk accounts:', error);
    if (error.code === 'ECONNABORTED' || error.message === 'Network Error') {
      throw new Error('Network Error');
    }
    throw error.response?.data || { message: 'Server unavailable' };
  }
};

export const createSipIpTrunkAccount = async (accountData) => {
  try {
    const response = await axiosInstance.post('/pjsip_ip_trunk', {
      type: 'create',
      data: {
        extension: accountData.extension,
        context: accountData.context,
        allow_codecs: accountData.allow_codecs,
        password: accountData.password,
        contact: accountData.contact,
        from_domain: accountData.from_domain,
        contact_user: accountData.contact_user,
        outbound_proxy: accountData.outbound_proxy,
      },
    });
    return response.data;
  } catch (error) {
    console.error('Error creating SIP IP Trunk account:', error);
    if (error.code === 'ECONNABORTED' || error.message === 'Network Error') {
      throw new Error('Network Error');
    }
    throw error.response?.data || { message: 'Server unavailable' };
  }
};

export const updateSipIpTrunkAccount = async (accountData) => {
  try {
    const response = await axiosInstance.post('/pjsip_ip_trunk', {
      type: 'update',
      data: {
        extension: accountData.extension,
        context: accountData.context,
        allow_codecs: accountData.allow_codecs,
        password: accountData.password,
        contact: accountData.contact,
        from_domain: accountData.from_domain,
        contact_user: accountData.contact_user,
        outbound_proxy: accountData.outbound_proxy,
      },
    });
    return response.data;
  } catch (error) {
    console.error('Error updating SIP IP Trunk account:', error);
    if (error.code === 'ECONNABORTED' || error.message === 'Network Error') {
      throw new Error('Network Error');
    }
    throw error.response?.data || { message: 'Server unavailable' };
  }
};

export const deleteSipIpTrunkAccount = async (extension) => {
  try {
    const response = await axiosInstance.post('/pjsip_ip_trunk', {
      type: 'delete',
      data: { extension },
    });
    return response.data;
  } catch (error) {
    console.error('Error deleting SIP IP Trunk account:', error);
    if (error.code === 'ECONNABORTED' || error.message === 'Network Error') {
      throw new Error('Network Error');
    }
    throw error.response?.data || { message: 'Server unavailable' };
  }
};

export const createSipAccount = async (accountData) => {
  try {
    const response = await axiosInstance.post('/pjsip', {
      type: 'create',
      data: {
        extension: accountData.extension,
        context: accountData.context,
        allow_codecs: accountData.allow_codecs,
        password: accountData.password,
        from_domain: accountData.from_domain,
        contact_user: accountData.contact_user,
        outbound_proxy: accountData.outbound_proxy
      }
    });
    return response.data;
  } catch (error) {
    console.error('Error creating SIP account:', error);
    if (error.code === 'ECONNABORTED' || error.message === 'Network Error') {
      throw new Error('Network Error');
    }
    throw error.response?.data || { message: 'Server unavailable' };
  }
};

export const updateSipAccount = async (accountData) => {
  try {
    const response = await axiosInstance.post('/pjsip', {
      type: 'update',
      data: {
        extension: accountData.extension,
        context: accountData.context,
        allow_codecs: accountData.allow_codecs,
        password: accountData.password,
        from_domain: accountData.from_domain,
        contact_user: accountData.contact_user,
        outbound_proxy: accountData.outbound_proxy
      }
    });
    return response.data;
  } catch (error) {
    console.error('Error updating SIP account:', error);
    if (error.code === 'ECONNABORTED' || error.message === 'Network Error') {
      throw new Error('Network Error');
    }
    throw error.response?.data || { message: 'Server unavailable' };
  }
};

export const deleteSipAccount = async (extension) => {
  try {
    const response = await axiosInstance.post('/pjsip', {
      type: 'delete',
      data: {
        extension: extension
      }
    });
    return response.data;
  } catch (error) {
    console.error('Error deleting SIP account:', error);
    if (error.code === 'ECONNABORTED' || error.message === 'Network Error') {
      throw new Error('Network Error');
    }
    throw error.response?.data || { message: 'Server unavailable' };
  }
};

// OpenVPN API Services
export const uploadOpenVpnFile = async (file) => {
  try {
    const formData = new FormData();
    formData.append('file', file);
    
    const response = await axiosInstance.post('/openvpnupload', formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    });
    return response.data;
  } catch (error) {
    console.error('Error uploading OpenVPN file:', error);
    if (error.code === 'ECONNABORTED' || error.message === 'Network Error') {
      throw new Error('Network Error');
    }
    throw error.response?.data || { message: 'Server unavailable' };
  }
};

export const startOpenVpn = async () => {
  try {
    const response = await axiosInstance.post('/openvpn_op', { type: 'start' });
    return response.data;
  } catch (error) {
    console.error('Error starting OpenVPN:', error);
    if (error.code === 'ECONNABORTED' || error.message === 'Network Error') {
      throw new Error('Network Error');
    }
    throw error.response?.data || { message: 'Server unavailable' };
  }
};

export const stopOpenVpn = async () => {
  try {
    const response = await axiosInstance.post('/openvpn_op', { type: 'stop' });
    return response.data;
  } catch (error) {
    console.error('Error stopping OpenVPN:', error);
    if (error.code === 'ECONNABORTED' || error.message === 'Network Error') {
      throw new Error('Network Error');
    }
    throw error.response?.data || { message: 'Server unavailable' };
  }
};

export const getOpenVpnStatus = async () => {
  try {
    const response = await axiosInstance.post('/openvpn_op', { type: 'status' });
    return response.data;
  } catch (error) {
    console.error('Error getting OpenVPN status:', error);
    if (error.code === 'ECONNABORTED' || error.message === 'Network Error') {
      throw new Error('Network Error');
    }
    throw error.response?.data || { message: 'Server unavailable' };
  }
};

export const getOpenVpnLogs = async () => {
  try {
    const response = await axiosInstance.post('/openvpn_op', { type: 'log' });
    return response.data;
  } catch (error) {
    console.error('Error getting OpenVPN logs:', error);
    if (error.code === 'ECONNABORTED' || error.message === 'Network Error') {
      throw new Error('Network Error');
    }
    throw error.response?.data || { message: 'Server unavailable' };
  }
};

// Warning Log API functions
export const getWarningLogs = async () => {
  try {
      // Linux CLI commands to fetch ONLY system infrastructure warnings from /var/log/
      const warningCommands = [
        // Check for LAN/Ethernet interface down warnings
        'grep -i "eth[0-9].*down\\|lan.*down\\|interface.*down" /var/log/messages 2>/dev/null | tail -10 || echo "LAN down warnings not found"',
        'grep -i "eth[0-9].*down\\|lan.*down\\|interface.*down" /var/log/syslog 2>/dev/null | tail -10 || echo "LAN down warnings not found in syslog"',
        
        // Check for PRI/ISDN down warnings
        'grep -i "pri.*down\\|isdn.*down\\|lapd.*down\\|lapd.*state.*0x0005" /var/log/messages 2>/dev/null | tail -10 || echo "PRI/ISDN down warnings not found"',
        'grep -i "pri.*down\\|isdn.*down\\|lapd.*down\\|lapd.*state.*0x0005" /var/log/syslog 2>/dev/null | tail -10 || echo "PRI/ISDN down warnings not found in syslog"',
        
        // Check for VPN down/connection issues
        'grep -i "vpn.*down\\|vpn.*fail\\|vpn.*error\\|openvpn.*down" /var/log/messages 2>/dev/null | tail -10 || echo "VPN down warnings not found"',
        'grep -i "vpn.*down\\|vpn.*fail\\|vpn.*error\\|openvpn.*down" /var/log/syslog 2>/dev/null | tail -10 || echo "VPN down warnings not found in syslog"',
        
        // Check for OpenVPN TLS errors and connection failures
        'grep -i "openvpn.*tls.*error\\|openvpn.*tls.*handshake\\|openvpn.*key.*negotiation\\|openvpn.*process.*restarting" /var/log/messages 2>/dev/null | tail -10 || echo "OpenVPN TLS errors not found"',
        'grep -i "openvpn.*tls.*error\\|openvpn.*tls.*handshake\\|openvpn.*key.*negotiation\\|openvpn.*process.*restarting" /var/log/syslog 2>/dev/null | tail -10 || echo "OpenVPN TLS errors not found in syslog"',
        
        // Check for VPN connectivity issues (network connectivity problems)
        'grep -i "vpn.*network.*connectivity\\|vpn.*connection.*timeout\\|vpn.*connection.*lost" /var/log/messages 2>/dev/null | tail -10 || echo "VPN connectivity warnings not found"',
        'grep -i "vpn.*network.*connectivity\\|vpn.*connection.*timeout\\|vpn.*connection.*lost" /var/log/syslog 2>/dev/null | tail -10 || echo "VPN connectivity warnings not found in syslog"',
        
        // Check for SIP registration failures
        'grep -i "sip.*register.*fail\\|sip.*register.*error\\|sip.*auth.*fail\\|sip.*timeout" /var/log/messages 2>/dev/null | tail -10 || echo "SIP registration warnings not found"',
        'grep -i "sip.*register.*fail\\|sip.*register.*error\\|sip.*auth.*fail\\|sip.*timeout" /var/log/syslog 2>/dev/null | tail -10 || echo "SIP registration warnings not found in syslog"',
        
        // Check for license invalid/expired warnings
        'grep -i "licen.*invalid\\|licen.*expir\\|licen.*fail\\|licen.*error" /var/log/messages 2>/dev/null | tail -10 || echo "License warnings not found"',
        'grep -i "licen.*invalid\\|licen.*expir\\|licen.*fail\\|licen.*error" /var/log/syslog 2>/dev/null | tail -10 || echo "License warnings not found in syslog"',
        
        // Check for DHCP server/client issues
        'grep -i "dhcp.*fail\\|dhcp.*error\\|dhcp.*timeout\\|dhcp.*lease.*fail" /var/log/messages 2>/dev/null | tail -10 || echo "DHCP warnings not found"',
        'grep -i "dhcp.*fail\\|dhcp.*error\\|dhcp.*timeout\\|dhcp.*lease.*fail" /var/log/syslog 2>/dev/null | tail -10 || echo "DHCP warnings not found in syslog"',
        
        // Check for NTP synchronization issues
        'grep -i "ntp.*fail\\|ntp.*error\\|ntp.*timeout\\|ntp.*sync.*fail" /var/log/messages 2>/dev/null | tail -10 || echo "NTP warnings not found"',
        'grep -i "ntp.*fail\\|ntp.*error\\|ntp.*timeout\\|ntp.*sync.*fail" /var/log/syslog 2>/dev/null | tail -10 || echo "NTP warnings not found in syslog"',
        
        // Check for PSTN trunk issues
        'grep -i "pstn.*down\\|pstn.*fail\\|pstn.*error\\|trunk.*down" /var/log/messages 2>/dev/null | tail -10 || echo "PSTN trunk warnings not found"',
        'grep -i "pstn.*down\\|pstn.*fail\\|pstn.*error\\|trunk.*down" /var/log/syslog 2>/dev/null | tail -10 || echo "PSTN trunk warnings not found in syslog"',
        
        // Check for Asterisk service issues
        'grep -i "asterisk.*fail\\|asterisk.*error\\|asterisk.*down" /var/log/messages 2>/dev/null | tail -10 || echo "Asterisk warnings not found"',
        'grep -i "asterisk.*fail\\|asterisk.*error\\|asterisk.*down" /var/log/syslog 2>/dev/null | tail -10 || echo "Asterisk warnings not found in syslog"',
        
        // Real-time check: Is eth1 physically down?
        'if ip link show eth1 2>/dev/null | grep -q "state DOWN"; then echo "$(date): WARNING: eth1 is physically DOWN!"; fi',
        
        // Real-time check: Is eth0 physically down?
        'if ip link show eth0 2>/dev/null | grep -q "state DOWN"; then echo "$(date): WARNING: eth0 is physically DOWN!"; fi',
        
        // Check if eth1 is UP but has no IP address (configuration issue)
        'if ip link show eth1 2>/dev/null | grep -q "state UP" && ! ip addr show eth1 2>/dev/null | grep -q "inet "; then echo "$(date): WARNING: eth1 is UP but has NO IP ADDRESS - configuration issue!"; fi',
        
        // Check if eth0 is UP but has no IP address (configuration issue)
        'if ip link show eth0 2>/dev/null | grep -q "state UP" && ! ip addr show eth0 2>/dev/null | grep -q "inet "; then echo "$(date): WARNING: eth0 is UP but has NO IP ADDRESS - configuration issue!"; fi',
        
        // Check for interfaces with no traffic (potential issue)
        'ifconfig 2>/dev/null | grep -A 5 "eth1:" | grep -q "RX packets 0.*TX packets 0" && echo "$(date): WARNING: eth1 has NO TRAFFIC - may be disconnected or misconfigured!" || true',
        'ifconfig 2>/dev/null | grep -A 5 "eth0:" | grep -q "RX packets 0.*TX packets 0" && echo "$(date): WARNING: eth0 has NO TRAFFIC - may be disconnected or misconfigured!" || true'
      ];
    
    // Try each command until we find warnings
    for (const cmd of warningCommands) {
      try {
        const response = await postLinuxCmd({ cmd });
        if (response.response && response.responseData && 
            !response.responseData.includes('not found') && 
            !response.responseData.includes('grep failed') &&
            response.responseData.trim()) {
          return {
            response: true,
            data: response.responseData,
            message: 'Warning logs retrieved successfully'
          };
        }
      } catch (error) {
        console.log(`Warning command failed: ${cmd}`, error.message);
        continue;
      }
    }
    
    // If no warnings found, return empty
    return {
      response: true,
      data: 'No warning logs found. System appears to be running normally.',
      message: 'No warnings found'
    };
  } catch (error) {
    console.error('Error getting warning logs:', error);
    throw error.response?.data || { message: 'Failed to retrieve warning logs' };
  }
};

export const downloadWarningLogs = async () => {
  try {
      // Comprehensive system infrastructure warning download commands
      const downloadCommands = [
        // Get LAN/Ethernet interface down warnings
        'grep -i "eth[0-9].*down\\|lan.*down\\|interface.*down" /var/log/* 2>/dev/null | sort || echo "LAN down warnings not found"',
        
        // Get PRI/ISDN down warnings
        'grep -i "pri.*down\\|isdn.*down\\|lapd.*down\\|lapd.*state.*0x0005" /var/log/* 2>/dev/null | sort || echo "PRI/ISDN down warnings not found"',
        
        // Get VPN down/connection issues
        'grep -i "vpn.*down\\|vpn.*fail\\|vpn.*error\\|openvpn.*down" /var/log/* 2>/dev/null | sort || echo "VPN down warnings not found"',
        
        // Get OpenVPN TLS errors and connection failures
        'grep -i "openvpn.*tls.*error\\|openvpn.*tls.*handshake\\|openvpn.*key.*negotiation\\|openvpn.*process.*restarting" /var/log/* 2>/dev/null | sort || echo "OpenVPN TLS errors not found"',
        
        // Get VPN connectivity issues
        'grep -i "vpn.*network.*connectivity\\|vpn.*connection.*timeout\\|vpn.*connection.*lost" /var/log/* 2>/dev/null | sort || echo "VPN connectivity warnings not found"',
        
        // Get SIP registration failures
        'grep -i "sip.*register.*fail\\|sip.*register.*error\\|sip.*auth.*fail\\|sip.*timeout" /var/log/* 2>/dev/null | sort || echo "SIP registration warnings not found"',
        
        // Get license invalid/expired warnings
        'grep -i "licen.*invalid\\|licen.*expir\\|licen.*fail\\|licen.*error" /var/log/* 2>/dev/null | sort || echo "License warnings not found"',
        
        // Get DHCP server/client issues
        'grep -i "dhcp.*fail\\|dhcp.*error\\|dhcp.*timeout\\|dhcp.*lease.*fail" /var/log/* 2>/dev/null | sort || echo "DHCP warnings not found"',
        
        // Get NTP synchronization issues
        'grep -i "ntp.*fail\\|ntp.*error\\|ntp.*timeout\\|ntp.*sync.*fail" /var/log/* 2>/dev/null | sort || echo "NTP warnings not found"',
        
        // Get PSTN trunk issues
        'grep -i "pstn.*down\\|pstn.*fail\\|pstn.*error\\|trunk.*down" /var/log/* 2>/dev/null | sort || echo "PSTN trunk warnings not found"',
        
        // Get Asterisk service issues
        'grep -i "asterisk.*fail\\|asterisk.*error\\|asterisk.*down" /var/log/* 2>/dev/null | sort || echo "Asterisk warnings not found"',
        
        // Real-time check: Current interface status
        'ip link show 2>/dev/null | grep -E "eth[01].*state DOWN" | while read line; do echo "$(date): WARNING: $line"; done',
        
        // Check for interfaces UP but with no IP address
        'for iface in eth0 eth1; do if ip link show $iface 2>/dev/null | grep -q "state UP" && ! ip addr show $iface 2>/dev/null | grep -q "inet "; then echo "$(date): WARNING: $iface is UP but has NO IP ADDRESS - configuration issue!"; fi; done',
        
        // Check for interfaces with no traffic
        'for iface in eth0 eth1; do if ifconfig 2>/dev/null | grep -A 5 "$iface:" | grep -q "RX packets 0.*TX packets 0"; then echo "$(date): WARNING: $iface has NO TRAFFIC - may be disconnected or misconfigured!"; fi; done'
      ];
    
    for (const cmd of downloadCommands) {
      try {
        const response = await postLinuxCmd({ cmd });
        if (response.response && response.responseData && 
            response.responseData.trim() &&
            !response.responseData.includes('not found') &&
            !response.responseData.includes('grep failed')) {
          return {
            response: true,
            data: response.responseData,
            message: 'All warning logs downloaded successfully'
          };
        }
      } catch (error) {
        console.log(`Download warning command failed: ${cmd}`, error.message);
        continue;
      }
    }
    
    return {
      response: true,
      data: 'No warning logs found for download.',
      message: 'No warnings found for download'
    };
  } catch (error) {
    console.error('Error downloading warning logs:', error);
    throw error.response?.data || { message: 'Failed to download warning logs' };
  }
};

// SQL Upload (Database patch uploader)
export const uploadSqlPatch = async (file) => {
  try {
    const formData = new FormData();
    formData.append('file', file);
    const response = await axiosInstance.post('/sqlupload', formData, {
      headers: { 'Content-Type': 'multipart/form-data' },
      timeout: 60000
    });
    return response.data;
  } catch (error) {
    console.error('Error uploading SQL patch:', error);
    throw error.response?.data || { success: false, message: error.message || 'Upload failed' };
  }
};



export const saveWhitelist = async (data) => {
  try {
    const response = await axiosInstance.post('/save-number-filter-settings', data);
    return response.data;
  } catch (error) {
    console.error('Error saving Whitelist', error.message);
    throw error;
  }
};

export const saveCallerWhitelist = async (data) => {
  try {
    const apiData = {
      type: "whitelist",
      group: String(data.groupNo),
      number: data.callerId,
      subtype: "callerid"
    };
    const response = await axiosInstance.post('/save-number-filter-settings', apiData);
    return response.data;
  } catch (error) {
    console.error('Error saving Caller Whitelist', error.message);
    throw error;
  }
};

export const saveCalleeWhitelist = async (data) => {
  try {
    const apiData = {
      type: "whitelist",
      group: String(data.groupNo),
      number: data.calleeId,
      subtype: "calleeid"
    };
    const response = await axiosInstance.post('/save-number-filter-settings', apiData);
    return response.data;
  } catch (error) {
    console.error('Error saving Callee Whitelist', error.message);
    throw error;
  }
};

export const fetchAllNumberFilters = async (type) => {
  try {
    // Try new endpoint first
    const response = await axiosInstance.post('/fetch-all-number-filters', {
      type: type
    });
    return response.data;
  } catch (error) {
    // Fallback to old endpoint if new one doesn't exist
    try {
      const response = await axiosInstance.get('/fetch-all-number-filters');
      if (response.data && response.data.success && response.data.data) {
        // Filter data based on type (whitelist/blacklist)
        const filteredData = response.data.data.filter(item => {
          if (type === 'whitelist') {
            return item.type === 'whitelist';
          } else if (type === 'blacklist') {
            return item.type === 'blacklist';
          }
          return true;
        });
        return {
          success: true,
          data: filteredData
        };
      }
      return response.data;
    } catch (fallbackError) {
      console.error('Error fetching number filters:', fallbackError.message);
      throw fallbackError;
    }
  }
};

export const fetchNumberFilters = async (type, number) => {
  try {
    const response = await axiosInstance.post('/fetch-number-filters', {
      type: type,
      number: number
    }, {
      timeout: 10000 // 10 second timeout
    });
    return response.data;
  } catch (error) {
    // Fallback to old search method if new endpoint doesn't exist
    try {
      const searchData = {
        caller_id: type === 'whitelist' || type === 'blacklist' ? number : "",
        callee_id: type === 'whitelist' || type === 'blacklist' ? "" : number
      };
      
      const response = await axiosInstance.post('/fetch-number-filters', searchData, {
        timeout: 10000
      });
      
      if (response.data && response.data.success && response.data.data) {
        // Filter data based on type
        const filteredData = response.data.data.filter(item => {
          if (type === 'whitelist') {
            return item.type === 'whitelist';
          } else if (type === 'blacklist') {
            return item.type === 'blacklist';
          }
          return true;
        });
        return {
          success: true,
          data: filteredData
        };
      }
      return response.data;
    } catch (fallbackError) {
      console.error('Error searching number filters:', fallbackError.message);
      throw fallbackError;
    }
  }
};

export const deleteNumberFilter = async (type, number, subtype, group) => {
  try {
    const response = await axiosInstance.post('/delete-number-filter-settings', {
      type: type,
      number: number,
      subtype: subtype,
      group: group
    });
    return response.data;
  } catch (error) {
    console.error('Error deleting number filter:', error.message);
    throw error;
  }
};

export const deleteAllNumberFilters = async (type, subtype) => {
  try {
    const response = await axiosInstance.post('/delete-all-number-filters', { 
      type: type,
      subtype: subtype
    });
    return response.data;
  } catch (error) {
    console.error('Error deleting all number filters:', error.message);
    throw error;
  }
};

// Blacklist API functions
export const saveCallerBlacklist = async (data) => {
  try {
    const apiData = {
      type: "blacklist",
      group: String(data.groupNo),
      number: data.callerId,
      subtype: "callerid"
    };
    const response = await axiosInstance.post('/save-number-filter-settings', apiData);
    return response.data;
  } catch (error) {
    console.error('Error saving Caller Blacklist', error.message);
    throw error;
  }
};

export const saveCalleeBlacklist = async (data) => {
  try {
    const apiData = {
      type: "blacklist",
      group: String(data.groupNo),
      number: data.calleeId,
      subtype: "calleeid"
    };
    const response = await axiosInstance.post('/save-number-filter-settings', apiData);
    return response.data;
  } catch (error) {
    console.error('Error saving Callee Blacklist', error.message);
    throw error;
  }
};

export const getAvailableTrunk = async () => {
  try {
    const response = await axiosInstance.get('/get-available-trunk');
    return response.data;
  } catch (error) {
    console.error('Error fetching available trunk data:', error.message);
    throw error;
  }
};

export const savePcmTrunkGroup = async (data) => {
  try {
    const apiData = {
      index: parseInt(data.index),
      description: data.description,
      trunkSelectMode: data.trunkSelectMode,
      backupTrunkGroup: data.backupTrunkGroup === 'None' ? 0 : parseInt(data.backupTrunkGroup),
      selectedTrunks: data.selectedTrunks.map(trunk => parseInt(trunk))
    };
    const response = await axiosInstance.post('/save-pcm-trunk-group', apiData);
    return response.data;
  } catch (error) {
    console.error('Error saving PCM trunk group:', error.message);
    throw error;
  }
};

export const getAllPcmTrunkGroup = async () => {
  try {
    const response = await axiosInstance.get('/get-all-pcm-trunk-group');
    return response.data;
  } catch (error) {
    console.error('Error fetching PCM trunk group data:', error.message);
    throw error;
  }
};

export const deletePcmTrunkGroup = async (index) => {
  try {
    const response = await axiosInstance.post('/delete-pcm-trunk-group', { index });
    return response.data;
  } catch (error) {
    console.error('Error deleting PCM trunk group:', error.message);
    throw error;
  }
};

export const deleteAllPcmTrunkGroups = async () => {
  try {
    const response = await axiosInstance.get('/delete-all-pcm-trunk-groups');
    return response.data;
  } catch (error) {
    console.error('Error deleting all PCM trunk groups:', error.message);
    throw error;
  }
};

// New PSTN GROUP APIs
export const listPstnGroups = async () => {
  try {
    const { data } = await axiosInstance.post('/pstngroups', { type: 'list' });
    return data;
  } catch (error) {
    console.error('Error listing PSTN groups:', error.message);
    throw error;
  }
};

export const savePstnGroup = async (groupId, pstnIds, description) => {
  try {
    const { data } = await axiosInstance.post('/pstngroups', {
      type: 'create',
      data: { group_id: String(groupId), pstn_ids: pstnIds, description },
    });
    return data;
  } catch (error) {
    console.error('Error saving PSTN group:', error.message);
    throw error;
  }
};

export const deletePstnGroup = async (groupId) => {
  try {
    const { data } = await axiosInstance.post('/pstngroups', {
      type: 'delete',
      data: { group_id: String(groupId) },
    });
    return data;
  } catch (error) {
    console.error('Error deleting PSTN group:', error.message);
    throw error;
  }
};

// SIP Registration API


export const createSipRegistration = async (data) => {
  try {
    const response = await axiosInstance.post("/trunk", {
      type: "create",
      data,
    });
    return response.data;
  } catch (error) {
    console.error("Error creating SIP registration:", error.message);
    throw error;
  }
};

export const listSipRegistrations = async () => {
  try {
    const response = await axiosInstance.post("/trunk", {
      type: "list",
    });
    return response.data;
  } catch (error) {
    console.error("Error listing SIP registrations:", error.message);
    throw error;
  }
};

export const updateSipRegistration = async (data) => {
  try {
    const response = await axiosInstance.post("/trunk", {
      type: "update",
      data,
    });
    return response.data;
  } catch (error) {
    console.error("Error updating SIP registration:", error.message);
    throw error;
  }
};

export const deleteSipRegistration = async (trunkId) => {
  try {
    const response = await axiosInstance.post("/trunk", {
      type: "delete",
      data: { trunk_id: trunkId }
    });
    return response.data;
  } catch (error) {
    console.error("Error deleting SIP registration:", error.message);
    throw error;
  }
};

// SIP Trunk API (same endpoints as SIP Registration)
export const listSipTrunks = async () => {
  try {
    const response = await axiosInstance.post("/trunk", {
      type: "list",
    });
    return response.data;
  } catch (error) {
    console.error("Error listing SIP trunks:", error.message);
    throw error;
  }
};

export const createSipTrunk = async (data) => {
  try {
    const response = await axiosInstance.post("/trunk", {
      type: "create",
      data,
    });
    return response.data;
  } catch (error) {
    console.error("Error creating SIP trunk:", error.message);
    throw error;
  }
};

export const updateSipTrunk = async (data) => {
  try {
    const response = await axiosInstance.post("/trunk", {
      type: "update",
      data,
    });
    return response.data;
  } catch (error) {
    console.error("Error updating SIP trunk:", error.message);
    throw error;
  }
};

export const deleteSipTrunk = async (trunkId) => {
  try {
    const response = await axiosInstance.post("/trunk", {
      type: "delete",
      data: { trunk_id: trunkId }
    });
    return response.data;
  } catch (error) {
    console.error("Error deleting SIP trunk:", error.message);
    throw error;
  }
};

// Global SIP settings (transport/SRTP/DTMF)
export const listGlobalSipSettings = async () => {
  try {
    const response = await axiosInstance.post('/global-sip', { type: 'list' });
    return response.data;
  } catch (error) {
    console.error('Error fetching global SIP settings:', error.message);
    throw error;
  }
};

export const updateGlobalSipSettings = async (settings) => {
  try {
    const response = await axiosInstance.post('/global-sip', {
      type: 'update',
      data: { settings },
    });
    return response.data;
  } catch (error) {
    console.error('Error updating global SIP settings:', error.message);
    throw error;
  }
};

// Config File API Services
export const fetchHostsFile = async () => {
  try {
    const response = await axiosInstance.post("/etc", {
      type: "list"
    });
    return response.data;
  } catch (error) {
    console.error("Error fetching hosts file:", error.message);
    if (error.code === 'ECONNABORTED' || error.message === 'Network Error') {
      throw new Error('Network Error');
    }
    throw error.response?.data || { message: 'Server unavailable' };
  }
};

export const updateHostsFile = async (contentData) => {
  try {
    const response = await axiosInstance.post("/etc", {
      type: "update",
      content_data: contentData
    });
    return response.data;
  } catch (error) {
    console.error("Error updating hosts file:", error.message);
    if (error.code === 'ECONNABORTED' || error.message === 'Network Error') {
      throw new Error('Network Error');
    }
    throw error.response?.data || { message: 'Server unavailable' };
  }
};

// New PSTN API Services
export const listPstn = async () => {
  try {
    const response = await axiosInstance.post("/pstn", {
      action: "list"
    });
    return response.data;
  } catch (error) {
    console.error("Error listing PSTN settings:", error);
    throw error;
  }
};

export const createPstn = async (data) => {
  try {
    const response = await axiosInstance.post("/pstn", {
      action: "create",
      span_id: data.span_id,
      span: data.span,
      channels: data.channels
    });
    return response.data;
  } catch (error) {
    console.error("Error creating PSTN settings:", error);
    throw error;
  }
};

export const deletePstn = async (spanId) => {
  try {
    const response = await axiosInstance.post("/pstn", {
      action: "delete",
      span_id: spanId
    });
    return response.data;
  } catch (error) {
    console.error("Error deleting PSTN settings:", error);
    throw error;
  }
};

// Number Receiving Rule API functions
export const listNumRecv = async () => {
  try {
    const response = await axiosInstance.post("/numrecv", { type: "list" });
    if (!response.data) {
      throw new Error('Empty response from server');
    }
    return response.data;
  } catch (error) {
    console.error('Error listing Number Receiving Rules:', error);
    if (error.code === 'ECONNABORTED') {
      throw new Error('Request timeout. Please try again.');
    } else if (error.response?.status === 404) {
      throw new Error('Number Receiving Rule API endpoint not found.');
    } else if (error.response?.status >= 500) {
      throw new Error('Server error. Please try again later.');
    } else if (error.message === 'Network Error') {
      throw new Error('Network connection failed. Please check your connection.');
    }
    throw error;
  }
};

export const createNumRecv = async (data) => {
  try {
    if (!data || !data.number_data || !data.provider) {
      throw new Error('Invalid data provided for Number Receiving Rule creation');
    }
    const response = await axiosInstance.post("/numrecv", {
      type: "create",
      data: {
        number_data: data.number_data,
        provider: data.provider
      }
    });
    return response.data;
  } catch (error) {
    console.error('Error creating Number Receiving Rule:', error);
    if (error.code === 'ECONNABORTED') {
      throw new Error('Request timeout. Please try again.');
    } else if (error.response?.status === 404) {
      throw new Error('Number Receiving Rule API endpoint not found.');
    } else if (error.response?.status >= 500) {
      throw new Error('Server error. Please try again later.');
    } else if (error.message === 'Network Error') {
      throw new Error('Network connection failed. Please check your connection.');
    }
    throw error;
  }
};

export const deleteNumRecv = async (id) => {
  try {
    if (!id) {
      throw new Error('ID is required for deletion');
    }
    const response = await axiosInstance.post("/numrecv", {
      type: "delete",
      data: {
        id: String(id)
      }
    });
    return response.data;
  } catch (error) {
    console.error('Error deleting Number Receiving Rule:', error);
    if (error.code === 'ECONNABORTED') {
      throw new Error('Request timeout. Please try again.');
    } else if (error.response?.status === 404) {
      throw new Error('Number Receiving Rule not found.');
    } else if (error.response?.status >= 500) {
      throw new Error('Server error. Please try again later.');
    } else if (error.message === 'Network Error') {
      throw new Error('Network connection failed. Please check your connection.');
    }
    throw error;
  }
};

// IP PSTN Route API Services
export const listIpPstnRoutes = async (routeType) => {
  try {
    const response = await axiosInstance.post('/ip_pstn_route', {
      type: 'list',
      data: routeType ? { route_type: routeType } : undefined
    });
    return response.data;
  } catch (error) {
    console.error('Error fetching IP PSTN routes:', error.message);
    throw error;
  }
};

export const createIpPstnRoute = async (data, routeType) => {
  try {
    const response = await axiosInstance.post('/ip_pstn_route', {
      type: 'create',
      data: routeType ? { ...data, route_type: routeType } : data
    });
    return response.data;
  } catch (error) {
    console.error('Error creating IP PSTN route:', error.message);
    throw error;
  }
};

export const updateIpPstnRoute = async (id, data, routeType) => {
  try {
    const response = await axiosInstance.post('/ip_pstn_route', {
      type: 'update',
      data: {
        id: id,
        ...data,
        ...(routeType ? { route_type: routeType } : {})
      }
    });
    return response.data;
  } catch (error) {
    console.error('Error updating IP PSTN route:', error.message);
    throw error;
  }
};

export const deleteIpPstnRoute = async (id, routeType) => {
  try {
    const response = await axiosInstance.post('/ip_pstn_route', {
      type: 'delete',
      data: {
        id: id,
        ...(routeType ? { route_type: routeType } : {})
      }
    });
    return response.data;
  } catch (error) {
    console.error('Error deleting IP PSTN route:', error.message);
    throw error;
  }
};

// Number Pool APIs
export const listNumberPool = async () => {
  try {
    const response = await axiosInstance.post('/numberpool', { type: 'list' });
    return response.data;
  } catch (error) {
    console.error('Error listing Number Pool:', error.message);
    throw error;
  }
};

export const createNumberPool = async (data) => {
  try {
    const response = await axiosInstance.post('/numberpool', { type: 'create', data });
    return response.data;
  } catch (error) {
    console.error('Error creating Number Pool entry:', error.message);
    throw error;
  }
};

export const updateNumberPool = async (id, data) => {
  try {
    const response = await axiosInstance.post('/numberpool', { type: 'update', data: { id, ...data } });
    return response.data;
  } catch (error) {
    console.error('Error updating Number Pool entry:', error.message);
    throw error;
  }
};

export const deleteNumberPool = async (id) => {
  try {
    const response = await axiosInstance.post('/numberpool', { type: 'delete', data: { id } });
    return response.data;
  } catch (error) {
    console.error('Error deleting Number Pool entry:', error.message);
    throw error;
  }
};

// Final Number Filter (Filtering Rule) APIs
export const listFinalNumberFilter = async () => {
  try {
    const response = await axiosInstance.post('/finalnumberfilter', { type: 'list' });
    return response.data;
  } catch (error) {
    console.error('Error listing final number filters:', error.message);
    throw error;
  }
};

export const createFinalNumberFilter = async (data) => {
  try {
    const response = await axiosInstance.post('/finalnumberfilter', {
      type: 'create',
      data
    });
    return response.data;
  } catch (error) {
    console.error('Error creating final number filter:', error.message);
    throw error;
  }
};

export const deleteFinalNumberFilter = async (id) => {
  try {
    const response = await axiosInstance.post('/finalnumberfilter', {
      type: 'delete',
      data: { id }
    });
    return response.data;
  } catch (error) {
    console.error('Error deleting final number filter:', error.message);
    throw error;
  }
};

// Number Manipulation API Services
export const listNumberManipulations = async (manipulationType = 'ip_in_callerid') => {
  try {
    const response = await axiosInstance.post('/number_manipulation', {
      type: 'list',
      data: { manipulation_type: manipulationType }
    });
    return response.data;
  } catch (error) {
    console.error('Error listing number manipulations:', error.message);
    throw error;
  }
};

export const createNumberManipulation = async (manipulationData, manipulationType = 'ip_in_callerid') => {
  try {
    const response = await axiosInstance.post('/number_manipulation', {
      type: 'create',
      data: {
        ...manipulationData,
        manipulation_type: manipulationType
      }
    });
    return response.data;
  } catch (error) {
    console.error('Error creating number manipulation:', error.message);
    throw error;
  }
};

export const updateNumberManipulation = async (manipulationData, manipulationType = 'ip_in_callerid') => {
  try {
    const response = await axiosInstance.post('/number_manipulation', {
      type: 'update',
      data: {
        ...manipulationData,
        manipulation_type: manipulationType
      }
    });
    return response.data;
  } catch (error) {
    console.error('Error updating number manipulation:', error.message);
    throw error;
  }
};

export const deleteNumberManipulation = async (id) => {
  try {
    const response = await axiosInstance.post('/number_manipulation', {
      type: 'delete',
      data: { id }
    });
    return response.data;
  } catch (error) {
    console.error('Error deleting number manipulation:', error.message);
    throw error;
  }
};

// ------------------------------
// Master SIP Settings API
// ------------------------------
export const listSipSettings = async () => {
  try {
    const response = await axiosInstance.post('/sip_settings', { type: 'list' });
    return response.data;
  } catch (error) {
    console.error('Error listing SIP settings:', error.message);
    throw error;
  }
};

export const updateSipSettings = async (settings) => {
  try {
    const response = await axiosInstance.post('/sip_settings', {
      type: 'update',
      data: { settings }
    });
    return response.data;
  } catch (error) {
    console.error('Error updating SIP settings:', error.message);
    throw error;
  }
};

// ------------------------------
// Media Settings API
// ------------------------------
export const listMediaSettings = async () => {
  try {
    const response = await axiosInstance.post('/media_settings', { type: 'list' });
    return response.data;
  } catch (error) {
    console.error('Error listing Media settings:', error.message);
    throw error;
  }
};

// ------------------------------
// SoftEther VPN API (proxied via backend base URL)
// ------------------------------
export const seCreateVpn = async (payload) => {
  try {
    const { data } = await axiosInstance.post('/createvpn', payload);
    return data;
  } catch (error) {
    throw error.response?.data || { message: error.message };
  }
};

export const seConnectVpn = async (connectionName) => {
  try {
    const { data } = await axiosInstance.post('/connectvpn', { connectionName });
    return data;
  } catch (error) {
    throw error.response?.data || { message: error.message };
  }
};

export const seDisconnectVpn = async (connectionName) => {
  try {
    const { data } = await axiosInstance.post('/disconnectvpn', { connectionName });
    return data;
  } catch (error) {
    throw error.response?.data || { message: error.message };
  }
};

export const seVpnEnable = async () => {
  try {
    const { data } = await axiosInstance.post('/vpnenable');
    return data;
  } catch (error) {
    throw error.response?.data || { message: error.message };
  }
};

export const seVpnDisable = async () => {
  try {
    const { data } = await axiosInstance.post('/vpndisable');
    return data;
  } catch (error) {
    throw error.response?.data || { message: error.message };
  }
};

export const seVpnSetCert = async (connectionName, certFile, keyFile) => {
  try {
    const formData = new FormData();
    formData.append('cert', certFile);
    formData.append('key', keyFile);
    formData.append('connectionName', connectionName);
    const { data } = await axiosInstance.post('/vpnsetcert', formData, {
      headers: { 'Content-Type': 'multipart/form-data' }
    });
    return data;
  } catch (error) {
    throw error.response?.data || { message: error.message };
  }
};

export const seAutoStartEnable = async (connectionName) => {
  try {
    const { data } = await axiosInstance.post('/vpnautostart', { connectionName });
    return data;
  } catch (error) {
    throw error.response?.data || { message: error.message };
  }
};

export const seAutoStartDisable = async (connectionName) => {
  try {
    const { data } = await axiosInstance.post('/vpnautostart', { connectionName });
    return data;
  } catch (error) {
    throw error.response?.data || { message: error.message };
  }
};

export const seVpnList = async () => {
  try {
    const { data } = await axiosInstance.post('/vpnlist');
    return data;
  } catch (error) {
    throw error.response?.data || { message: error.message };
  }
};

export const seVpnDelete = async (connectionName) => {
  try {
    const { data } = await axiosInstance.post('/vpndelete', { connectionName });
    return data;
  } catch (error) {
    throw error.response?.data || { message: error.message };
  }
};

export const seVpnState = async () => {
  try {
    const { data } = await axiosInstance.post('/vpnstate');
    return data;
  } catch (error) {
    throw error.response?.data || { message: error.message };
  }
};

export const seVpnStatus = async (connectionName) => {
  try {
    const { data } = await axiosInstance.post('/vpnstatus', { connectionName });
    return data;
  } catch (error) {
    // For 500 errors, return the error data instead of throwing
    if (error.response && error.response.status === 500) {
      return error.response.data;
    }
    throw error.response?.data || { message: error.message };
  }
};


export const updateMediaSettings = async (settings) => {
  try {
    const response = await axiosInstance.post('/media_settings', {
      type: 'update',
      data: { settings },
    });
    return response.data;
  } catch (error) {
    console.error('Error updating Media settings:', error.message);
    throw error;
  }
};

// ==============================
// Backup/Restore API
// ==============================
export const downloadBackup = async () => {
  try {
    // API is POST: always use POST to retrieve the backup tar as a blob
    const response = await axiosInstance.request({
      url: '/backup',
      method: 'post',
      responseType: 'blob',
      timeout: 60000,
    });

    // Try to infer filename from headers, fallback to backup.tar
    const contentDisposition = response.headers['content-disposition'] || '';
    const fileNameMatch = /filename\*=UTF-8''([^;]+)|filename="?([^";]+)"?/i.exec(contentDisposition);
    const fileName = decodeURIComponent(fileNameMatch?.[1] || fileNameMatch?.[2] || 'backup.tar');

    return { blob: response.data, fileName };
  } catch (error) {
    console.error('Error downloading backup:', error);
    // Surface meaningful error
    const message = error.response?.data?.message || error.message || 'Backup download failed';
    throw new Error(message);
  }
};

export const restoreBackup = async (file) => {
  try {
    if (!file) throw new Error('Please select a .tar file to upload');
    if (!/\.tar$/i.test(file.name)) throw new Error('Only .tar files are supported');

    const formData = new FormData();
    formData.append('file', file);

    const { data } = await axiosInstance.post('/restore', formData, {
      headers: { 'Content-Type': 'multipart/form-data' },
      timeout: 120000,
    });

    return data; // Expecting { response: true, message: '...' }
  } catch (error) {
    console.error('Error restoring backup:', error);
    const message = error.response?.data?.message || error.message || 'Restore failed';
    throw new Error(message);
  }
};

// Helper function to manage user IDs in localStorage
export const getUserIds = () => {
  try {
    const stored = localStorage.getItem('userManageIds');
    return stored ? JSON.parse(stored) : [];
  } catch (error) {
    console.error('Error reading user IDs from localStorage:', error);
    return [];
  }
};

export const saveUserId = (userId) => {
  try {
    const ids = getUserIds();
    if (!ids.includes(userId)) {
      ids.push(userId);
      localStorage.setItem('userManageIds', JSON.stringify(ids));
    }
  } catch (error) {
    console.error('Error saving user ID to localStorage:', error);
  }
};

export const removeUserId = (userId) => {
  try {
    const ids = getUserIds();
    const filtered = ids.filter(id => id !== userId);
    localStorage.setItem('userManageIds', JSON.stringify(filtered));
  } catch (error) {
    console.error('Error removing user ID from localStorage:', error);
  }
};

// User Management API Functions
export const createUser = async (userData) => {
  try {
    const response = await axiosInstance.post('/admin/create-user', userData);
    // If user was created successfully, save the ID to localStorage
    if (response.data && response.data.response && response.data.data && response.data.data.id) {
      saveUserId(response.data.data.id);
    }
    return response.data;
  } catch (error) {
    console.error('Error creating user:', error);
    const message = error.response?.data?.message || error.message || 'Failed to create user';
    throw new Error(message);
  }
};

export const getUser = async (userId) => {
  try {
    const response = await axiosInstance.get(`/admin/get-user/${userId}`);
    console.log(`getUser(${userId}) response:`, response.data);
    return response.data;
  } catch (error) {
    console.error('Error fetching user:', error);
    const message = error.response?.data?.message || error.message || 'Failed to fetch user';
    throw new Error(message);
  }
};

export const updateUser = async (userId, userData) => {
  try {
    // Backend expects: { userId, username, password, userAuthority, pagePermissions, channelPermissions }
    const rawId = userId ?? userData?.id ?? userData?.userId;
    if (!rawId && rawId !== 0) {
      throw new Error('User ID is required for update');
    }

    const numericId =
      typeof rawId === 'string' ? parseInt(rawId, 10) : Number(rawId);

    if (isNaN(numericId) || numericId <= 0) {
      throw new Error(`Invalid user ID: ${rawId}`);
    }

    const payload = {
      userId: numericId,
      username: userData.username,
      password: userData.password,
      userAuthority:
        userData.userAuthority ??
        userData.permission ??
        userData.role ??
        'read-only',
      pagePermissions: userData.pagePermissions || {},
      channelPermissions: userData.channelPermissions || {},
    };

    console.log(
      'updateUser final payload:',
      JSON.stringify(payload, null, 2),
    );

    const response = await axiosInstance.post('/admin/update-user', payload);
    return response.data;
  } catch (error) {
    console.error('Error updating user:', error);
    console.error('Error response:', error.response?.data);
    const message =
      error.response?.data?.message ||
      error.message ||
      'Failed to update user';
    throw new Error(message);
  }
};

export const listUsers = async () => {
  try {
    // Use /admin/get-all-users endpoint which returns users with permissions
    console.log('Fetching all users from /admin/get-all-users...');
    const response = await axiosInstance.get('/admin/get-all-users');
    
    console.log('Full API response:', response.data);
    
    if (response.data && response.data.response !== false) {
      // Handle different response structures
      let usersData = null;
      
      if (response.data.data) {
        usersData = response.data.data;
      } else if (Array.isArray(response.data)) {
        usersData = response.data;
      }
      
      if (!usersData) {
        console.log('No users data in response');
        return { response: true, data: [] };
      }
      
      console.log('Received users data:', usersData);
      
      // Transform API data to match expected format
      // The API returns users with pagePermissions and channelPermissions already included
      const users = Array.isArray(usersData) ? usersData.map(user => {
        // Handle different response structures
        if (user.user) {
          // If user data is nested under 'user' property (like get-user response)
          return {
            ...user.user,
            pagePermissions: user.pagePermissions || {},
            channelPermissions: user.channelPermissions || {}
          };
        } else {
          // If user data is already flat with permissions
          return {
            id: user.id,
            username: user.username,
            permission: user.permission,
            pagePermissions: user.pagePermissions || {},
            channelPermissions: user.channelPermissions || {},
            created_at: user.created_at
          };
        }
      }) : [];
      
      console.log('Transformed users:', users);
      return { response: true, data: users };
    }
    
    console.log('API returned response: false');
    return { response: true, data: [] };
  } catch (error) {
    console.error('Error listing users:', error);
    console.error('Error response:', error.response?.data);
    // Return empty array on error
    return { response: true, data: [] };
  }
};

export const deleteUser = async (userId) => {
  try {
    const response = await axiosInstance.post('/admin/delete-user', { id: userId });
    // If user was deleted successfully, remove the ID from localStorage
    if (response.data && response.data.response) {
      removeUserId(userId);
    }
    return response.data;
  } catch (error) {
    console.error('Error deleting user:', error);
    const message = error.response?.data?.message || error.message || 'Failed to delete user';
    throw new Error(message);
  }
};
